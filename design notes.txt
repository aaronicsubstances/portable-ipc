ScalableIPC Notes
===========
C#.NET Core implementation
- exception stacktrace in promise rejection (e.g during send if prev send pending) not showing in tests. Will they also be missing outside test environment?
- which interface methods are going to be virtual, or all? Prefer containment to inheritance.
- add try catch as much as possible for robustness

Event Loop Libraries
---------------------
C# - Custom task scheduler with no parallelism and synchronization lock, and CancellationToken for cancelTimeout
Java - Port C# solution.
NodeJS - setImmediate().
*Consider Python since it has event loop, future, async sleep
Ruby?

Web Server Interfaces for use with HTTP frameworks over non-TCP
--------------------------------------------------------------------
Python - WSGI
C#.NET Core - OWIN
Ruby - Rack
Java - Servlet Container. Undertow.io looks like what will fit our purpose, by writing custom listeners and handlers, and handling async I/O.

NodeJS - Effectively http.createServer(app). where app is the framework (e.g. ExpressJs).
 - Basically mimick http module. And then when http.createServer(app) is called, our internal logic kicks in. Example: https://www.npmjs.com/package/node-fastcgi

*For client calls, libraries will have to be built for each platform

POSTULATE on network communication patterns and distributed systems
=========================================================================
Every network communication pattern or problem can be solved by a combination of
- existing internet protocols of HTTP/TCP/IP
- faster context specific existing protocols like in memory funcion calls, UDP, Windows named pipe, Unix domain socket
- transport layer abstraction - precisely what scalable-ipc provides in reliable send, and unreliable send (fire and forget)
- custom network topology. needed to handle all sorts of communication patterns.
- distributed datastore. needed to handle distributed computing.
- write once datastore, e.g. Write-Ahead Logging. needed to handle race conditions (in practice will delete but well after data is not needed). 
- non-distributed datastore. needed to handle large traffic volumes