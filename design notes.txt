ScalableIPC Notes
===========
C#.NET Core implementation
- exception stacktrace in promise rejection (e.g during send if prev send pending) not showing in tests. Will they also be missing outside test environment?
- which interface methods are going to be virtual, or all? Prefer containment to inheritance.
- add try catch as much as possible for robustness

Event Loop Libraries
---------------------
C# - Custom task scheduler with no parallelism and synchronization lock, and CancellationToken for cancelTimeout
Java - Port C# solution.
NodeJS - setImmediate().
*Consider Python since it has event loop, future, async sleep
Ruby?

Web Server Interfaces for use with HTTP frameworks over non-TCP
--------------------------------------------------------------------
Python - WSGI
C#.NET Core - OWIN
Ruby - Rack
Java - Servlet Container. Undertow.io looks like what will fit our purpose, by writing custom listeners and handlers, and handling async I/O.

NodeJS - Effectively http.createServer(app). where app is the framework (e.g. ExpressJs).
 - Basically mimick http module. And then when http.createServer(app) is called, our internal logic kicks in. Example: https://www.npmjs.com/package/node-fastcgi

*For client calls, libraries will have to be built for each platform

Basis of software consultancy
 - increasing degrees of freedom when choosing software architecture with regards to deployment and data storage. 
 - That is, going for 3 instead of 1 degrees of freedom.
 - "email for computer agents" as the scalable, maintainable, vendor-neutral way to implement asynchronous communication 
   (commonly done with message queues or publish-suscribe event systems).

POSTULATE on network communication patterns and distributed systems
=========================================================================
Every network communication pattern or problem can be solved by a combination of
- existing internet protocols of HTTP/TCP/IP
- faster context specific existing protocols like in memory function calls, UDP, Windows named pipe, Unix domain socket
- transport layer abstraction - precisely what scalable-ipc provides in reliable send, and unreliable send (fire and forget)
- event loop abstraction - precisely what library offers, to handle multithreading race conditions.
- custom network topology. needed to handle all sorts of communication patterns.
- distributed datastore. needed to handle distributed computing.
- write once datastore, ie append-only log. needed to implement some guarantees amidst concurrency.
- non-distributed read-write datastore. needed by default to store data.
